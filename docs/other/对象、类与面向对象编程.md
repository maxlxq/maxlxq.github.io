
## 对象

创建自定义对象
- new 关键字 + Object 构造函数
- 对象字面量

### 属性的类型

属性分为：数据属性和访问器属性

1. 数据属性

包含一个保存数据值的位置。

数据属性有 4 个特性描述它们的行为。
- [[Configurable]]: 表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改成访问器属性。默认为 true
- [[Enumerable]]: 表示属性是否可以通过 for-in 循环返回。默认为 true
- [[Writable]]: 表示属性的值是否可以被修改。默认为 true
- [[Value]]: 包含属性实际的值。默认为 undefined

要修改属性的默认特性，就必须使用 Object.defineProperty() 方法。

Object.defineProperty() 接收三个参数：要给其添加属性的对象、属性的名称和一个描述符对象。
描述符对象上的属性可以包含：configurable、enumerable、writable、value。

```javascript
let person = {}
Object.defineProperty(person, 'name', {
  writable: false,
  value: 'dan'
})

console.log(person.name) // dan
person.name = 'ge'
console.log(person.name) // ge
```

一个属性被定义为不可配置之后，就不能再变回可配置的了。

2. 访问器属性

访问器属性不包含数据值。它们包含一个获取函数和一个设置函数，但不是必需的。

访问器属性有 4 个特性描述它们的行为：
- [[Configurable]]: 表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认为 true
- [[Enumerable]]: 表示属性是否可以通过 for-in 循环返回。默认为 true
- [[Get]]: 获取函数，在读取属性时调用。默认 undefined
- [[Set]]: 设置函数，在写入属性时调用。默认 undefined

访问器属性不能直接定义，必须使用 Object.defineProperty()。

获取函数和设置函数不一定都要定义。指定以获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。
只有一个设置函数的属性是不能读取的，费严格模式下读取会返回 undefined，严格模式下会抛出错误。

在不支持 Object.defineProperty() 的浏览器中没办法修改 [[Configurable]] 和 [[Enumerable]]

### 定义多个属性

Object.defineProperties() 方法可以通过多个描述符一次性定义多个属性。
接受两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。

```javascript
let book = {}
Object.defineProperties(book, {
  year_: {
    value: 2021,
  },
  edition: {
    value: 1,
  },

  year: {
    get() {
      return this.year_
    },
    set(newValue) {
      if (newValue > 2021) {
        this.year_ = newValue
        this.edition += newValue - 2021
      }
    }
  }
})
```

### 读取属性的特性

使用 Object.getOwnPropertyDescriptor() 方法可以取得指定属性的属性描述符。

接受两个参数：属性所在的对象和要取得其描述的属性名。

返回值：一个对象

```javascript
let book = {}
Object.defineProperties(book, {
  year_: {
    value: 2021,
  },
  edition: {
    value: 1,
  },
  year: {
    get: function () {
      return this.year
    },
    set: function(newValue) {
      if (newValue > 2021) {
        this.year_ = newValue
        this.edition += newValue - 2021
      }
    }
  }
})

let descriptor = Object.getOwnPropertyDescriptor(book, 'year_')
console.log(descriptor.value) // 2021
console.log(descriptor.configurable) // false
console.log(typeof descriptor.get) // 'undefined'
let descriptor = Object.getOwnPropertyDescriptor(book, 'year')
console.log(descriptor.value) // undefined
console.log(descriptor.configurable) // false
console.log(typeof descriptor.get) // 'function'
```

ECMAScript 2017 新增了 Object.getOwnPropertyDescriptors() 静态方法。这个方法实际上会在每个自有属性上调用 Object.getOwnPropertyDescriptor() 并在一个新对象中返回它们。

```javascript
let book = {}
Object.defineProperties(book, {
  year_: {
    value: 2021
  },
  edition: {
    value: 1
  },
  year: {
    get: function () {
      return this.year_
    },
    set: function (newValue) {
      if (newValue > 2021) {
        this.year_ = newValue;
        this.edition += newValue - 2021
      }
    }
  }
})
console.log(Object.getOwnPropertyDescriptors(book))
// {
//   edition: {
//     configurable: false,
//     enumerable: false,
//     value: 1,
//     writable: false
//   },
//   year: {
//     configurable: false,
//       enumerable: false,
//       get: f(),
//       set: f(newValue),
//   },
//   year_: {
//     configurable: false,
//     enumerable: false,
//     value: 2021,
//     writable: false
//   }
// }
```

### 合并对象

