
# 期约与异步函数

- 异步编程
- 期约
- 异步函数

ECMAScript 6 及之后的几个版本加大了对异步编程机制的支持。

ECMAScript 6 新增了正式的 Promise 引用类型，支持优雅地定义和组织异步编程逻辑。

接下来的几个版本增加了使用 async 和 await 关键字定义异步函数的机制。

## 异步编程

### 同步与异步

同步行为对应内存中顺序执行的处理器指令。
每条指令严格按照出现的顺序执行。
每条指令执行后也能立即获得存储在系统本地的信息。

异步行为类似于系统中断，当前进程外部的实体可以触发代码执行。
异步操作是必要的，代码执行一些高延时的操作，如果在同步操作中，必须要等待操作完成才能进行下一个指令，那么就会出现很长时间的等待。
而异步操作可以避免等待，直接进行下一个指令。

如果需要用到异步执行的代码返回的数据，可以使用回调或者事件系统。

#### 以往的异步编程模式

使用 setTimeout + 回调函数，延迟若干毫秒，把回调函数推到消息队列上去等待执行。

回调函数 可以设置为 成功回调、失败回调；成功回调也可以是一个异步操作。

**回调地狱**就是因为回调函数中存在新的异步操作的回调函数，层层嵌套，不具有扩展性。

## 期约

期约是对尚不存在结果的一个替身。

### Promise/A+ 规范

ECMAScript 6 增加了对 Promise/A+ 规范的完善支持，即 Promise 类型。
所有的现代浏览器都支持 ES6 期约，很多其他浏览器 API 也以期约为基础。

### 期约基础

ECMAScript 6 新增的引用类型 Promise，可以通过 new 操作符来实例化。

创建新期约时需要传入执行器函数作为参数。

```javascript
let p = new Promise(() => {}) // 如果不提供执行器函数，就会抛出 SyntaxError
console.log(p)
// Promise {<pending>}
```

1. 期约状态机

- 待定 pending
- 兑现 fulfilled
- 拒绝 rejected

pending 是期约的最初始状态。此状态下可以落定为 代表成功的兑现状态，或者代表失败的拒绝状态。

落定后的状态不再改变。并且状态是私有的，不能通过 JavaScript 检测到。

2. 解决值、拒绝理由及期约用例

期约有两大用途。
- 抽象地表示一个异步操作：pending 正在执行中，fulfilled 成功完成，rejected 没有成功完成。
- 期约封装异步操作会实际生成某个值，期约状态改变时可以访问这个值。

为了支持这两种用例，每个期约只要状态切换为 fulfilled 就会有一个私有的内部值 value，类似的，每个期约只要状态切换为拒绝，就会有一个私有的内部理由 reason。

3. 通过执行函数控制期约状态

由于期约的状态是私有的，所以只能在内部进行操作。

内部操作在期约的执行器函数中完成。

执行器函数主要有两个职责：初始化期约的异步行为、控制状态的最终转换。

执行器函数有两个参数：resolve()、reject()。

- 调用 resolve() 会把状态切换为 fulfilled。
- 调用 reject() 会把状态切换为 rejected。

```javascript
let p1 = new Promise((resolve, reject) => resolve())
let p2 = new Promise((resolve, reject) => reject())

console.log(p1) // Promise {<fulfilled>}
console.log(p2) // Promise {<rejected>}
```

当 resolve() 或 reject() 其中一个执行后，后续的 resolve() 和 reject() 都会静默失败。

```javascript
let p = new Promise((resolve, reject) => {
  resolve()
  reject() // 无效
})
```

4. Promise.resolve()

期约并非一开始就必须处于待定状态，然后通过执行器才能转换为落定状态。

通过调用 Promise.resolve() 静态方法，可以实例化一个解决的期约。

```javascript
// 以下两种生成实例其实是一样的
let p1 = new Promise((resolve, reject) => resolve())
let p2 = Promise.resolve()
```

这个解决的期约的值对应着传给 Promise.resolve() 的第一个参数，多余的参数会忽略。
使用这个静态方法，实际上可以把任何值都转换为一个期约。
并且 Promise.resolve() 对于传参是一个期约的时候，相当于一个空包装，可以说具有幂等性。

```javascript
Promise.resolve(3)
// Promise <fulfilled>: 3
```

5. Promise.reject()

与 Promise.resolve() 类似。

区别：当 Promise.reject() 接受一个期约对象时，这个期约会成为它返回的拒绝期约的理由。

6. 同步/异步执行的二元性

期约抛出的错误需要通过异步模式捕获。

期约真正的异步特性：是同步对象（可以在同步执行模式中使用），但也是异步执行模式的媒介。

### 期约的实例方法

1. 实现 Thenable 接口

在 ECMAScript 暴露的异步结构中，任何对象都有一个 then() 方法。这个方法被认为实现了 Thenable 接口。

```javascript
class MyThenable {
  then() {}
}
```

Promise 类型 实现了 Thenable 接口。

2. Promise.prototype.then()

Promise.prototype.then() 是为期约实例添加处理程序的主要方法。

这个 then() 方法接收最多的两个参数：onResolved 处理程序 和 onRejected 处理程序。

then() 接收到非函数处理程序时会被静默忽略。

```javascript
let p1 = new Promise((resolve, reject) => resolve())
let p2 = Promise.resolve()

// onResolved 不传入的规范写法
p1.then(null, () => console.log('p1'))
```

then() 方法返回一个新的期约实例。

```javascript
let p1 = new Promise(() => {})
let p2 = p1.then()

console.log(p1) // Promise <pending>
console.log(p2) // Promise <pending>
console.log(p1 === p2) // false
```

如果没有显式的返回语句，则 Promise.resolve() 会包装默认返回的 undefined。

如果有显式的返回语句，则 Promise.resolve() 会包装这个值。

抛出异常会返回拒绝的 期约。

3. Promise.prototype.catch()

Promise.prototype.catch() 用于给期约添加拒绝处理程序。
只接收一个参数：onRejected 处理程序。

相当于调用 Promise.prototype.then(null, onRejected)

```javascript
let p = Promise.reject();
let onRejected = function(e) {
  setTimeout(console.log, 0, 'rejected')
}
// 这两种添加拒绝处理程序的方式是一样的:
p.then(null, onRejected)
// rejected
p.catch(onRejected)
// rejected
```

返回期约与 then() 方法一样。

4. Promise.prototype.finally()

用于清理代码。会把期约原模原样的向后传递。

5. 非重入期约方法

当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。

如：一个解决期约上调用 then() 会把 onResolved() 处理程序推进消息队列。在当前线程上的同步代码执行完成前不会执行。

即，进入微任务队列，等待同步代码执行完毕后继续执行。

```javascript
let synchronousResolve;
// 创建一个期约并将解决函数保存在一个局部变量中
let p = new Promise((resolve) => {
  synchronousResolve = function() {
    console.log('1: invoking resolve()')
    resolve()
    console.log('2: resolve() returns') // 同步代码，在 resolve() 之后也会执行
  }
})

p.then(() => console.log('4: then() handler executes'))
synchronousResolve()
console.log('3: synchronousResolve() returns')
// 实际的输出:
// 1: invoking resolve()
// 2: resolve() returns
// 3: synchronousResolve() returns
// 4: then() handler executes
```

### 期约连锁与期约合成

1. 期约连锁

即，链式调用，执行一串同步任务。

串行化异步任务，每个后续期约都等待之前的期约。

将生成期约的代码提取到一个工厂函数中。

2. 期约图

因为一个期约可以有任意多个处理程序，所以期约连锁可以构建有向非循环图的结构。

3. Promise.all() 和 Promise.race()

4. 串行期约合成

异步产生值并将其串给处理程序。

基于后续期约使用之前期约的返回值来串联期约是期约的基本功能。

类似于函数合成。

```javascript
function addTwo(x) { return x + 2 }
function addThree(x) { return x + 3 }
function addFive(x) { return x + 5 }

// 函数合成
function addTen(x) {
  return addFive(addThree(addTwo(x)))
}

// 使用期约也可以合成起来，渐进地消费一个值，并返回一个结果
function addTenThen(x) {
  return Promise.resolve(x)
    .then(addFive)
    .then(addThree)
    .then(addTwo)
}

// 也可以使用 reduce 简写
function addTenReduce(x) {
  return [addTwo, addThree, addFive]
    .reduce((promise, fn) => promise.then(fn), Promise.resolve(x))
}

// 抽取一个合成函数
function compose(...fns) {
  return (x) => fns.reduce((promise, fn) => promise.then(fn), Promise.resolve(x))
}

let addTenCompose = compose(addTwo, addThree, addFive)

addTenCompose(8).then(console.log) // 18
```

## 期约扩展

### 期约取消
