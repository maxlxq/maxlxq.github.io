(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{506:function(t,v,a){"use strict";a.r(v);var _=a(27),e=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"原始值与引用值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原始值与引用值"}},[t._v("#")]),t._v(" 原始值与引用值")]),t._v(" "),a("p",[t._v("原始值：最简单的数据类型，如：Undefined、Null、Boolean、Number、String、Symbol、BigInt")]),t._v(" "),a("p",[t._v("引用值：多个值组成的、保存在内存中的对象。")]),t._v(" "),a("h3",{attrs:{id:"动态属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态属性"}},[t._v("#")]),t._v(" 动态属性")]),t._v(" "),a("p",[t._v("引用值：可以随时添加、修改和删除其属性和方法。")]),t._v(" "),a("p",[t._v("原始值：不能有属性，尽管尝试添加属性并不会报错。")]),t._v(" "),a("h3",{attrs:{id:"复制值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复制值"}},[t._v("#")]),t._v(" 复制值")]),t._v(" "),a("p",[t._v("原始值：通过变量复制时，原始值会被复制到新变量的位置，互不影响。")]),t._v(" "),a("p",[t._v("引用值：通过变量复制时，存储在变量中的值也会被复制到新变量所在的位置。这个值实际上是一个指针，指向存储在堆内存中的对象。复制后，两个变量实际上指向同一对象，因此一个变量上的变化会在另外一个对象上反映出来。")]),t._v(" "),a("h3",{attrs:{id:"传递参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传递参数"}},[t._v("#")]),t._v(" 传递参数")]),t._v(" "),a("p",[t._v("ECMAScript 中所有函数的参数都是按值传递的。")]),t._v(" "),a("p",[t._v("原始值，会复制到函数内部的参数。")]),t._v(" "),a("p",[t._v("引用值，复制指针的值到函数内部参数。所以函数内部对参数的修改，会反映到函数外部引用值变量中。")]),t._v(" "),a("h3",{attrs:{id:"确定类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#确定类型"}},[t._v("#")]),t._v(" 确定类型")]),t._v(" "),a("p",[t._v("typeof 操作符，"),a("span",{staticStyle:{color:"#7643ef"}},[t._v("是判断一个变量是否为 字符串、数值、布尔值或 undefined 的最好方式")]),t._v("。")]),t._v(" "),a("p",[t._v("typeof 对原始值很有用，但对引用值的用处不大。")]),t._v(" "),a("p",[t._v("instanceof 操作符，如果变量是给定引用类型的实例，则 instanceof 操作符返回 true。")]),t._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" variable "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("constructor")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测任何引用值和 Object 的构造函数都会返回 true。如果用 instanceof 检测原始值，则始终会返回 false，因为原始值不是对象。")]),t._v(" "),a("blockquote",[a("p",[t._v("typeof 操作符在用于检测函数时也会返回 “function”。ECMA-262 规定，任何实现内部 [[Call]] 方法的对象都应该在 typeof 检测时返回 “function”。在 Safari 和 Chrome 中返回 “function”，在 IE 和 FireFox 中返回 “object”。")])]),t._v(" "),a("h2",{attrs:{id:"执行上下文和作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文和作用域"}},[t._v("#")]),t._v(" 执行上下文和作用域")]),t._v(" "),a("p",[t._v("执行上下文，变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每一个上下文都有一个关联的变量对象，这个上下文中定义的所有变量和函数都存在于这个对象上。")]),t._v(" "),a("p",[t._v("全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。浏览器中是 window 对象。")]),t._v(" "),a("p",[t._v("每个函数都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript 程序的执行流就是通过这个上下文栈进行控制的。")]),t._v(" "),a("p",[t._v("上下文中的代码在执行的时候，会创建变量对象的一个"),a("code",[t._v("作用域链")]),t._v("。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其"),a("code",[t._v("活动对象")]),t._v("用作变量对象。活动对象最初只有一个定义变量："),a("code",[t._v("arguments")]),t._v("。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推，直至全局上下文。全局上下文的变量对象始终是作用域链的最后一个变量对象。")]),t._v(" "),a("p",[t._v("代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）")]),t._v(" "),a("blockquote",[a("p",[t._v("函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。")])]),t._v(" "),a("h3",{attrs:{id:"作用域链增强"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域链增强"}},[t._v("#")]),t._v(" 作用域链增强")]),t._v(" "),a("p",[t._v("执行上下文主要有两种："),a("code",[t._v("全局上下文")]),t._v("、"),a("code",[t._v("函数上下文")]),t._v("。（eval() 调用内部存在第三种上下文，但不推荐使用，严格模式下禁止使用。）")]),t._v(" "),a("p",[t._v("某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。如：")]),t._v(" "),a("ul",[a("li",[t._v("try/catch 语句的 catch 块")]),t._v(" "),a("li",[t._v("with 语句")])]),t._v(" "),a("p",[t._v("这两种情况都会在作用域链前端添加一个变量对象。"),a("br"),t._v("\n对 with 语句来说，会向作用域链前端添加指定的对象；"),a("br"),t._v("\n对 catch 语句来说，会创建一个新的变量对象，包含要抛出的错误对象的声明。")]),t._v(" "),a("h3",{attrs:{id:"变量声明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量声明"}},[t._v("#")]),t._v(" 变量声明")]),t._v(" "),a("p",[t._v("ES6 之后，增加了 let 和 const 两个关键字，并且使用优先级上高于 var，成为了首选。")]),t._v(" "),a("ol",[a("li",[t._v("使用 var 的函数声明作用域")])]),t._v(" "),a("p",[t._v("使用 var 声明变量时，变量会被自动添加到最接近的上下文。"),a("br"),t._v("\n在函数中，添加到函数局部上下文。")]),t._v(" "),a("p",[t._v("如果函数未经声明就被初始化，那么它会自动被添加到全局上下文。")]),t._v(" "),a("blockquote",[a("p",[t._v("严格模式下，未经声明就初始化变量会报错。")])]),t._v(" "),a("p",[t._v("var 生命会被拿到函数或全局作用域顶部，位于作用域中所有代码之前。这个现象叫做“变量提升”。"),a("br"),t._v("\n提升让"),a("code",[t._v("同一作用域")]),t._v("中的代码不必考虑变量是否已经声明就可以直接使用。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("使用 let 的块级作用域声明")])]),t._v(" "),a("p",[t._v("块级作用域是由最近的一对包含花括号 "),a("code",[t._v("{}")]),t._v(" 界定。")]),t._v(" "),a("p",[t._v("let 的行为非常适合再循环中声明迭代变量。使用 var 生命的迭代变量会泄露到循环外部。")]),t._v(" "),a("p",[t._v("严格来讲，let 在 JavaScript 运行时中也会被提升，但由于“"),a("span",{staticStyle:{color:"#9421ff"}},[t._v("暂时性死区")]),t._v("（temporal dead zone，简称TDZ）”的缘故，实际上不能在声明前使用 let 变量。因此，"),a("a",{attrs:{href:"https://262.ecma-international.org/6.0/#sec-let-and-const-declarations",title:"Let and Const Declarations",target:"_blank",rel:"noopener noreferrer"}},[t._v("let 的提升"),a("OutboundLink")],1),t._v(" 和 var 的提升 是不一样的。")]),t._v(" "),a("blockquote",[a("p",[t._v("当程序的控制流程在新的作用域（"),a("code",[t._v("module function")]),t._v(" 或 "),a("code",[t._v("block")]),t._v(" 作用域）进行实例化时，在此作用域中用let/const声明的变量会先在作用域中被创建出来，但因"),a("span",{staticStyle:{color:"#0033ee"}},[t._v("此时还未进行词法绑定")]),t._v("，所以是不能被访问的，如果访问就会抛出错误。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("使用 const 的常量声明")])]),t._v(" "),a("p",[t._v("使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。其他方面与 let 声明保持一致。")]),t._v(" "),a("p",[t._v("const 声明之应用到顶级原语或者对象。赋值为对象的 const 变量不能再被重新赋值为其它引用值，但对象的键则不受限制。")]),t._v(" "),a("p",[t._v("由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。Google V8 引擎就执行这种优化。")]),t._v(" "),a("blockquote",[a("p",[t._v("尽可能地多使用 const 声明")])]),t._v(" "),a("h3",{attrs:{id:"标识符查找"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标识符查找"}},[t._v("#")]),t._v(" 标识符查找")]),t._v(" "),a("p",[t._v("当在特定上下文中为读取或写入而引入一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文忠找到该标识符，则搜索停止，变量确定；如果没有找到，则继续沿作用域链搜索。这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。")]),t._v(" "),a("blockquote",[a("p",[t._v("标识符查找并非没有代价，访问局部变量比访问全局变量要快，因为不用切换作用域。")])]),t._v(" "),a("h2",{attrs:{id:"垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),a("p",[t._v("JavaScript 是通过自动内存管理实现内存分配和闲置资源回收的。执行环境负责在代码执行时管理内存。")]),t._v(" "),a("p",[t._v("垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量主要有两种标记策略：标记清理、引用计数。")]),t._v(" "),a("h3",{attrs:{id:"标记清理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记清理"}},[t._v("#")]),t._v(" 标记清理")]),t._v(" "),a("p",[t._v("当变量进入上下文时，会被加上存在于上下文中的标记。当变量离开上下文时，也会被加上离开上下文的标记。")]),t._v(" "),a("p",[t._v("给变量加标记的方式。1 反转某一位；2 维护”在上下文中” 和 “不在上下文中” 两个变量列表，把变量从一个列表移动到的另外一个列表。")]),t._v(" "),a("p",[t._v("垃圾回收程序运行时，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后在被加上标记的变量就是待删除了，原因是任何在上下文忠的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁代表记得所有值并收回它们的内存。")]),t._v(" "),a("h3",{attrs:{id:"引用计数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[t._v("#")]),t._v(" 引用计数")]),t._v(" "),a("p",[t._v("对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，那么引用数加 1.相应地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1.当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。")]),t._v(" "),a("p",[t._v("循环引用问题，两个函数通过各自的属性互相引用，在函数结束后，根据引用计数策略，它们的引用数不会变成 0，会继续存在在内存中。为了避免循环引用造成的内存泄漏，在函数尾部，将内部不用的属性设置为 null，即可清除前面建立的循环引用。")])])}),[],!1,null,null,null);v.default=e.exports}}]);