(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{451:function(a,s,t){"use strict";t.r(s);var n=t(27),e=Object(n.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"前端基础建设与架构-工程化管理工具篇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端基础建设与架构-工程化管理工具篇"}},[a._v("#")]),a._v(" 前端基础建设与架构-工程化管理工具篇")]),a._v(" "),t("ul",[t("li",[a._v("项目依赖出现问题时，删除大法好，即删除 node_modules 和 lockfile，再重新 install，这样操作是否存在风险？")]),a._v(" "),t("li",[a._v("把所有依赖都安装到 dependencies 中，不区分 devDependencies 会有问题吗？")]),a._v(" "),t("li",[a._v("我们的应用依赖了公共库 A 和公共库 B，同时公共库 A 也依赖了公共库 B，那么公共库 B 会被多次安装或重复打包吗？")]),a._v(" "),t("li",[a._v("一个项目中，既有人用 npm，也有人用 Yarn，这会引发什么问题？")]),a._v(" "),t("li",[a._v("我们是否应该提交 lockfile 文件到项目仓库呢？")])]),a._v(" "),t("h2",{attrs:{id:"_01-npm-安装机制及企业及部署私服原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_01-npm-安装机制及企业及部署私服原理"}},[a._v("#")]),a._v(" 01｜npm 安装机制及企业及部署私服原理")]),a._v(" "),t("h3",{attrs:{id:"npm-内部机制和核心原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#npm-内部机制和核心原理"}},[a._v("#")]),a._v(" npm 内部机制和核心原理")]),a._v(" "),t("ul",[t("li",[a._v("npm 安装机制")])]),a._v(" "),t("blockquote",[t("p",[a._v("npm install => 检查 config => 判断有无 lock 文件 => 如下分支")])]),a._v(" "),t("blockquote",[t("p",[a._v("1 存在 lock 文件 => 是否和 package.json 声明版本")]),a._v(" "),t("p",[a._v("=> 一致 则进行 "),t("code",[a._v("检查缓存")])]),a._v(" "),t("p",[a._v("=> 不一致 则根据 package.json 和 package-lock.json 进行安装和更新 lockfile")])]),a._v(" "),t("blockquote",[t("p",[a._v("2 不存在 lock 文件 => 获取包信息 => 构建依赖树 => "),t("code",[a._v("检查缓存")])])]),a._v(" "),t("blockquote",[t("p",[a._v("检查缓存 => 无 => 下载资源包 => 检查完整性 => 添加到缓存")]),a._v(" "),t("p",[a._v("检查缓存 => 有 => 解压到 node_modules => 生产 lock 文件")])]),a._v(" "),t("ul",[t("li",[a._v("npm 缓存机制")])]),a._v(" "),t("h3",{attrs:{id:"npm-不完全指南"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#npm-不完全指南"}},[a._v("#")]),a._v(" npm 不完全指南")]),a._v(" "),t("ul",[t("li",[a._v("自定义 npm init")]),a._v(" "),t("li",[a._v("npm link，调试验证包的可用性")]),a._v(" "),t("li",[a._v("npx 的作用")])]),a._v(" "),t("h3",{attrs:{id:"npm-多元镜像和企业及部署私服原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#npm-多元镜像和企业及部署私服原理"}},[a._v("#")]),a._v(" npm 多元镜像和企业及部署私服原理")]),a._v(" "),t("blockquote",[t("p",[a._v("我们可以通过 npm config set 命令来设置安装源或者某个 scope 对应的安装源，很多企业也会搭建自己的 npm 源.")]),a._v(" "),t("p",[a._v("部署镜像后，确保高速、稳定的 npm 服务，而且使用发布的私有模块更加安全。审核机制上也可以保证私服上的 npm 模块质量和安全。")])]),a._v(" "),t("div",{staticClass:"language-json line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[a._v('"scripts"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token property"}},[a._v('"preinstall"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"node ./bin/preinstall.js"')]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("div",{staticClass:"language-javascript line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// preinstall.js")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("require")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("' child_process'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("exec")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'npm config get registry'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("error"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" stdout"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" stderr")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!")]),a._v("stdout"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("toString")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("match")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("registry\\.x\\.com")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("exec")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'npm config set @xscope:registry https://xxx.com/npm/'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("p",[a._v("现在社区上主要有 3 种工具来搭建 npm 私服："),t("code",[a._v("nexus")]),a._v("、"),t("code",[a._v("verdaccio")]),a._v(" 以及 "),t("code",[a._v("cnpm")]),a._v("。")]),a._v(" "),t("ul",[t("li",[a._v("Nexus 工作原理")])]),a._v(" "),t("p",[a._v("nexus 工作在 client 和外部 npm 之间，并通过 group repository 合并 npm 仓库以及私有仓库，起到代理转发的作用。")]),a._v(" "),t("ul",[t("li",[a._v("npm 配置作用优先级")])]),a._v(" "),t("p",[a._v("命令行配置 > env 环境变量设置 > .npmrc [项目级 > 用户级 > 全局级 > 内置]")]),a._v(" "),t("ul",[t("li",[a._v("npm 镜像和安装问题")])]),a._v(" "),t("p",[a._v("网络层面解决问题，正如大部分公司目前使用的科学上网环境")]),a._v(" "),t("h3",{attrs:{id:"_01-总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_01-总结"}},[a._v("#")]),a._v(" 01 ｜ 总结")]),a._v(" "),t("ul",[t("li",[a._v("npm 内部机制和核心原理\n"),t("ul",[t("li",[a._v("npm 的安装机制和背后思想")]),a._v(" "),t("li",[a._v("npm 缓存机制")])])]),a._v(" "),t("li",[a._v("npm 不完全指南\n"),t("ul",[t("li",[a._v("自定义 npm init")]),a._v(" "),t("li",[a._v("npm link，调试验证包的可用性")]),a._v(" "),t("li",[a._v("npx 的作用")])])]),a._v(" "),t("li",[a._v("npm 多元镜像和企业级部署私服原理")])]),a._v(" "),t("h2",{attrs:{id:"_02-yarn-的安装理念及如何破解依赖管理困境"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_02-yarn-的安装理念及如何破解依赖管理困境"}},[a._v("#")]),a._v(" 02 ｜ Yarn 的安装理念及如何破解依赖管理困境")]),a._v(" "),t("p",[a._v("新的 JavaScript 包管理器。为了解决历史上 npm 的某些不足。")]),a._v(" "),t("blockquote",[t("p",[a._v("npm 不足：对依赖的完整性和一执行保障；安装速度过慢；")]),a._v(" "),t("p",[a._v("不过，npm 后续版本吸收了 yarn 的优势特点(比如 一致性安装校验算法)")])]),a._v(" "),t("p",[a._v("yarn 理念")]),a._v(" "),t("ul",[t("li",[a._v("确定性：yarn.lock 机制，相同的依赖关系在任何机器和环境下，都可以以相同的方式被安装；（在 npm v5 之前，没有 package-lock.json 机制）")]),a._v(" "),t("li",[a._v("模块扁平化安装模式：将依赖包的不同版本，按照一定策略，归结于单个版本，避免创建多个副本造成冗余")]),a._v(" "),t("li",[a._v("网络性能更好：Yarn 采用了请求排队的理念，类似并发连接池，能够更好地利用网络资源；同时引入了更好的安装失败时的重试机制")]),a._v(" "),t("li",[a._v("采用缓存机制，实现了离线模式")])]),a._v(" "),t("h3",{attrs:{id:"yarn-安装机制和背后思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#yarn-安装机制和背后思想"}},[a._v("#")]),a._v(" Yarn 安装机制和背后思想")]),a._v(" "),t("p",[a._v("Yarn 的安装过程有 5 步："),t("br"),a._v("\n检测 checking --\x3e 解析包 resolving packages --\x3e 获取包 fetching packages --\x3e 链接包 linking packages --\x3e 构建包 building packages")]),a._v(" "),t("h4",{attrs:{id:"检测包-checking"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#检测包-checking"}},[a._v("#")]),a._v(" 检测包 Checking")]),a._v(" "),t("p",[a._v("检测项目中是否存在一些 npm 相关的文件；检查系统 OS、CPU 等信息；")]),a._v(" "),t("h4",{attrs:{id:"解析包-resolving-packages"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解析包-resolving-packages"}},[a._v("#")]),a._v(" 解析包 Resolving Packages")]),a._v(" "),t("p",[a._v("解析依赖树中的每一个包的版本信息")]),a._v(" "),t("ul",[t("li",[a._v("获取当前项目中定义的 dependencies、dveDependencies、optionalDependencies")]),a._v(" "),t("li",[a._v("采用遍历首层依赖的方式获取依赖包的版本信息，递归查找每个依赖下的嵌套依赖的版本信息，并将解析过和正在解析的包的引用用一个 Set 数据结构来存储，保证同一版本范围内的包不会被重复解析\n"),t("ul",[t("li",[a._v("未解析过的包 A，首次尝试从 yarn.lock 中获取到版本信息，并标记为已解析")]),a._v(" "),t("li",[a._v("如果在 yarn.lock 中没有找到包 A，则向 Registry 发起请求获取满足版本范围的已知最高版本的包信息，获取后将当前包解析为已解析")])])]),a._v(" "),t("li",[a._v("确定所有依赖的具体版本信息以及下载地址")])]),a._v(" "),t("h4",{attrs:{id:"获取包-fetching-packages"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#获取包-fetching-packages"}},[a._v("#")]),a._v(" 获取包 Fetching Packages")]),a._v(" "),t("blockquote",[t("p",[a._v("Q: 如何判断缓存中是否存在当前的依赖包？")]),a._v(" "),t("p",[a._v("A: Yarn 会根据 cacheFolder + slug + node_modules + pkg.name 生成一个 path，判断系统中是否存在该 path，"),t("br"),a._v("\n如果存在则证明已经有缓存，不用重新下载，这个 path 也就是依赖包缓存的具体路径。")])]),a._v(" "),t("ul",[t("li",[a._v("检查缓存中是否存在当前依赖包，同时将缓存中不存在的依赖包下载到缓存目录\n"),t("ul",[t("li",[a._v("没有命中缓存的包，Yarn 会维护一个 fetch 队列，按照规则进行网络请求。")]),a._v(" "),t("li",[a._v("如果下载包地址是一个 file 协议，亦或是相对路径，就说明其指向一个本地目录，此时调用 Fetch From Local 从离线缓存中获取包")]),a._v(" "),t("li",[a._v("否则调用 Fetch From External 获取包。最终获取结果使用 fs.createWriteStream 写入到缓存目录。")])])])]),a._v(" "),t("h4",{attrs:{id:"链接包-linking-packages"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链接包-linking-packages"}},[a._v("#")]),a._v(" 链接包 Linking Packages")]),a._v(" "),t("p",[a._v("将项目中的依赖复制到项目 node_modules 下，同时遵守扁平化规则。"),t("br"),a._v("\n在复制依赖前，Yarn 会先解析 peerDependencies，如果找不到符合 peerDependencies 的包，则进行 warning 提示，并最终拷贝依赖到项目中")]),a._v(" "),t("blockquote",[t("p",[a._v("扁平化原则")]),a._v(" "),t("p",[a._v("使用 Set 数据结构，存储同一版本的包信息。npm dedupe")])]),a._v(" "),t("h4",{attrs:{id:"构建包-building-packages"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构建包-building-packages"}},[a._v("#")]),a._v(" 构建包 Building Packages")]),a._v(" "),t("p",[a._v("如果依赖包中存在二进制包需要进行编译，会在这一步进行。")]),a._v(" "),t("h3",{attrs:{id:"破解依赖管理困境"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#破解依赖管理困境"}},[a._v("#")]),a._v(" 破解依赖管理困境")]),a._v(" "),t("blockquote",[t("p",[a._v("什么是嵌套地狱")]),a._v(" "),t("p",[a._v("项目依赖树的层级非常深，不利于调试和排查问题；"),t("br"),a._v("\n依赖树的不同分支里，可能存在同样版本的相同依赖。")])]),a._v(" "),t("h3",{attrs:{id:"_02-总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_02-总结"}},[a._v("#")]),a._v(" 02 ｜ 总结")]),a._v(" "),t("ul",[t("li",[a._v("Yarn 安装机制和背后思想\n"),t("ul",[t("li",[a._v("Yarn 解决的问题")]),a._v(" "),t("li",[a._v("Yarn 安装过程")])])]),a._v(" "),t("li",[a._v("破解依赖管理困境\n"),t("ul",[t("li",[a._v("删除 node_modules 重新安装，利用 npm 的依赖分析能力，得到更清爽的结构")]),a._v(" "),t("li",[a._v("使用 npm dedupe 命令")]),a._v(" "),t("li",[a._v("Yarn 自动执行 npm dedupe 命令")])])])]),a._v(" "),t("h2",{attrs:{id:"_03-ci-环境上的-npm-优化及更多工程化问题解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_03-ci-环境上的-npm-优化及更多工程化问题解析"}},[a._v("#")]),a._v(" 03 ｜ CI 环境上的 npm 优化及更多工程化问题解析")])])}),[],!1,null,null,null);s.default=e.exports}}]);