(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{457:function(a,e,r){"use strict";r.r(e);var t=r(27),v=Object(t.a)({},(function(){var a=this,e=a.$createElement,r=a._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"javascript-异步解决方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript-异步解决方案"}},[a._v("#")]),a._v(" JavaScript 异步解决方案")]),a._v(" "),r("ul",[r("li",[a._v("什么是异步？")])]),a._v(" "),r("blockquote",[r("p",[a._v("上一个任务被执行时，不会等待任务执行结束就去执行下一任务，等上一个任务执行完成后，将执行其返回的回调函数，这是异步操作")])]),a._v(" "),r("ul",[r("li",[a._v("为什么用异步？")])]),a._v(" "),r("blockquote",[r("p",[a._v("JS 是单线程的，因此必须等待上一个任务完成后，才能执行后一个任务。当一个任务比较耗时就会影响整个程序的执行，异步就是为了解决这种问题。")])]),a._v(" "),r("h2",{attrs:{id:"回调函数-callback"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回调函数-callback"}},[a._v("#")]),a._v(" 回调函数 callback")]),a._v(" "),r("p",[a._v("将回调函数作为实参传入另一个函数，并在函数内部被调用，用来完成某些任务。"),r("br"),a._v("\n如：setTimeout、ajax请求、readFile等")]),a._v(" "),r("p",[a._v("缺点：回调地狱，代码结构混乱，不易维护")]),a._v(" "),r("h2",{attrs:{id:"事件发布订阅"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事件发布订阅"}},[a._v("#")]),a._v(" 事件发布订阅")]),a._v(" "),r("p",[a._v("利用事件绑定，对某些任务进行监听，并根据变化执行相应任务。"),r("br"),a._v("\n即：观察者模式；"),r("br"),a._v("\n如：Node 的 events、DOM 的事件绑定；")]),a._v(" "),r("p",[a._v("优点：时间对象上的解耦"),r("br"),a._v("\n缺点：消耗内存，过度使用会难易维护")]),a._v(" "),r("h2",{attrs:{id:"promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[a._v("#")]),a._v(" Promise")]),a._v(" "),r("p",[a._v("Promise 是 ES6 提出的异步编程的一种解决方案")]),a._v(" "),r("p",[a._v("详见："),r("RouterLink",{attrs:{to:"/base/JavaScript-Promise.html"}},[a._v("Promise")])],1),a._v(" "),r("p",[a._v("优点：解决了回调地狱问题，将异步操作以同步操作的流程进行表达"),r("br"),a._v("\n缺点：无法取消 promise。如果不设置回调函数，Promise 内部会抛出错误，不会反映到外部。"),r("br"),a._v("\n多个 Promise 连续执行时，链式调用 .then 会显得很臃肿")]),a._v(" "),r("h2",{attrs:{id:"generator"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#generator"}},[a._v("#")]),a._v(" Generator")]),a._v(" "),r("p",[a._v("Generator 是 ES6 提出的另一种异步编程的解决方案。"),r("br"),a._v("\n需要在函数之前加上一个 "),r("code",[a._v("*")]),a._v(" 符号，函数内部使用 "),r("code",[a._v("yield")]),a._v(" 语句。"),r("br"),a._v("\nGenerator 函数会返回一个遍历器，可以进行遍历操作 "),r("code",[a._v(".next()")]),a._v(" 执行每个中断点 "),r("code",[a._v("yield")]),a._v("。")]),a._v(" "),r("p",[a._v("优点：没有 "),r("code",[a._v("Promise")]),a._v(" 的一堆 "),r("code",[a._v("then()")]),a._v("，异步操作更像同步"),r("br"),a._v("\n缺点：不是自动执行异步操作，需要手动执行多个 .next() 方法，需要配合 Thunk 函数或 Co 模块实现自动执行；"),r("br"),a._v("\n根据 done 属性判断是否执行完成；")]),a._v(" "),r("h2",{attrs:{id:"async-await"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[a._v("#")]),a._v(" async/await")]),a._v(" "),r("p",[r("code",[a._v("async/await")]),a._v(" 是 ES7 引入的异步解决方案，可以理解为 Generator 的语法糖，async 等同于 Generator 和 Co 模块的封装，async 函数返回一个 Promise。")]),a._v(" "),r("p",[a._v("优点：内置执行器，比 Generator 操作更简单。返回值为 Promise 对象，可以用 then 指定下一步操作。"),r("br"),a._v("\n代码更整洁，可以捕获同步和异步的错误。")])])}),[],!1,null,null,null);e.default=v.exports}}]);