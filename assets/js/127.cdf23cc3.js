(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{502:function(t,v,_){"use strict";_.r(v);var a=_(27),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"react-栈调和过程是怎样的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react-栈调和过程是怎样的"}},[t._v("#")]),t._v(" React 栈调和过程是怎样的")]),t._v(" "),_("p",[t._v("从 React 15 入手，理解 栈调和 算法")]),t._v(" "),_("h2",{attrs:{id:"调和过程与-diff-算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#调和过程与-diff-算法"}},[t._v("#")]),t._v(" 调和过程与 Diff 算法")]),t._v(" "),_("p",[t._v("调和（Reconciliation），又译为 协调。")]),t._v(" "),_("blockquote",[_("p",[t._v("通过如 ReactDOM 等类库使之与 真实 DOM 同步。"),_("br"),t._v("\n这一过程叫做协调（调和）。")])]),t._v(" "),_("p",[t._v("调和指的是将虚拟 DOM 映射到真实 DOM 的过程，Diff 过程只是其中一个环节。")]),t._v(" "),_("p",[t._v("React 源码结构佐证了这一点：React 从大的板块上将源码划分为 Core、Renderer、Reconciler 三部分。")]),t._v(" "),_("p",[t._v("其中 Reconciler 调和器所做的工作是一系列的，包括组件的挂载、卸载、更新等过程，其中更新过程涉及对 Diff 算法的调用。")]),t._v(" "),_("p",[t._v("所以，"),_("code",[t._v("调和 !== Diff")]),t._v("。但 Diff 确实是调和过程中最具有代表性的一环。")]),t._v(" "),_("p",[t._v('根据 Diff 实现形式的不同，调和过程被划分为 以 React 15 为主的"栈调和" 以及 以 React 16 为主的"Fiber 调和"。')]),t._v(" "),_("h2",{attrs:{id:"diff-策略的设计思想"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#diff-策略的设计思想"}},[t._v("#")]),t._v(" Diff 策略的设计思想")]),t._v(" "),_("p",[t._v("Diff 算法本质上是找不同的过程。")]),t._v(" "),_("p",[t._v("计算机领域上找出两个树结构之间的不同，需要通过循环递归进行树节点的一一对比。这个时间复杂度是 O(n^3)。")]),t._v(" "),_("p",[t._v("但 O(n^3) 的复杂度是不能被接受的，所以我们需要优化。")]),t._v(" "),_("p",[t._v("React 团队总结了以下两个规律，为将 O(n^3) 转换成 O(n) 确定了大前提：")]),t._v(" "),_("ul",[_("li",[t._v("若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构。")]),t._v(" "),_("li",[t._v("处于同一层的一组子节点，可通过设置 key 作为唯一标识，从而维护各个节点在不同渲染过程中的稳定性。")])]),t._v(" "),_("p",[t._v("除了这两个规律之外，还有一个规律，为 React 实现高效的 Diff 提供了灵感："),_("strong",[t._v("DOM 节点之间的跨层级操作并不多，同层级操作是主流")]),t._v("。")]),t._v(" "),_("h2",{attrs:{id:"把握三个要点-解释-diff-逻辑"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#把握三个要点-解释-diff-逻辑"}},[t._v("#")]),t._v(" 把握三个要点，解释 Diff 逻辑")]),t._v(" "),_("ol",[_("li",[t._v('Diff 算法性能突破的关键点在于"分层对比"')]),t._v(" "),_("li",[t._v("类型一致的节点才有继续 Diff 的必要性")]),t._v(" "),_("li",[t._v("key 属性的设置，可以帮我们尽可能重用同一层级内的节点")])]),t._v(" "),_("h3",{attrs:{id:"分层对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分层对比"}},[t._v("#")]),t._v(" 分层对比")]),t._v(" "),_("p",[t._v("结合第三规律：同层级操作是主流。React 的 Diff 过程 直接放弃了跨层级的节点比较，它只针对相同层级的节点做对比。")]),t._v(" "),_("p",[t._v("如此一来，只需要从上到下做一次遍历，就可以完成整棵树的对比。")]),t._v(" "),_("p",[t._v("销毁 + 重建的代价是昂贵的，因此 不要做跨层级的操作，尽量保持 DOM 结构的稳定性。")]),t._v(" "),_("h3",{attrs:{id:"减少递归-类型的一致性决定递归的必要性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#减少递归-类型的一致性决定递归的必要性"}},[t._v("#")]),t._v(" 减少递归：类型的一致性决定递归的必要性")]),t._v(" "),_("p",[t._v("本着主要矛盾的原则，React 任务，只有同类型的组件，才有进一步对比的必要性。")]),t._v(" "),_("p",[t._v("若 参与 Diff 的两个组件类型不同，那么直接放弃比较，原地替换掉旧节点。只有相同类型的组件，React 才会保留组件对应 DOM 树 或 子树，进行更深层次的遍历。")]),t._v(" "),_("h3",{attrs:{id:"重用节点-key-属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重用节点-key-属性"}},[t._v("#")]),t._v(" 重用节点：key 属性")]),t._v(" "),_("p",[t._v("key 是用来帮助 React 识别哪些内容被更改、添加或删除。key 需要卸载用数组渲染出来的元素内部，并且需要赋予一个稳定的值。如果 key 发生了变更，React 则会直接触发重渲染。")]),t._v(" "),_("p",[t._v("解决的问题：同一层级下节点的重用问题。")])])}),[],!1,null,null,null);v.default=e.exports}}]);