(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{370:function(t,e,a){t.exports=a.p+"assets/img/react_lifestyle.c34d5543.png"},392:function(t,e,a){"use strict";a.r(e);var r=a(27),_=Object(r.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"react"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),r("blockquote",[r("p",[t._v("转载自掘金文章："),r("a",{attrs:{href:"https://juejin.cn/post/6898635086657224717",target:"_blank",rel:"noopener noreferrer"}},[t._v("React17 源码分析"),r("OutboundLink")],1),t._v("\nauthor: "),r("a",{attrs:{href:"https://juejin.cn/user/1415826705485128",target:"_blank",rel:"noopener noreferrer"}},[t._v("xfz"),r("OutboundLink")],1)])]),t._v(" "),r("h2",{attrs:{id:"_15-版本特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_15-版本特点"}},[t._v("#")]),t._v(" 15 版本特点")]),t._v(" "),r("p",[t._v("React 15 的架构分为两层")]),t._v(" "),r("ul",[r("li",[t._v("Reconciler 协调器：用于收集需要更新的组件、patch Vnode 更新标识")]),t._v(" "),r("li",[t._v("Renderer 渲染器：将变化后的组件进行 dom-diff => 渲染到页面上")])]),t._v(" "),r("blockquote",[r("p",[t._v("15版本的reconciler 是 stack-reconciler。采用递归方式工作，同步进行，在生成虚拟dom树并diff的时候无法中断。")]),t._v(" "),r("p",[t._v("当组件层级过深时，会造成线程一直被占用，浏览器无法布局和绘制，造成丢帧、卡顿")])]),t._v(" "),r("h2",{attrs:{id:"_16-版本特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_16-版本特点"}},[t._v("#")]),t._v(" 16 版本特点")]),t._v(" "),r("p",[t._v("React 16 的架构分为三层")]),t._v(" "),r("ul",[r("li",[t._v("Scheduler 调度器：调度任务的优先级，高优先级的优先进入 Reconciler 阶段")]),t._v(" "),r("li",[t._v("Reconciler 协调器：收集需要更新的组件：fiber root 构建 - patch - Vnode 标识")]),t._v(" "),r("li",[t._v("Renderer 渲染器：将变化后的组件进行 dom-diff => 渲染到页面上")])]),t._v(" "),r("h2",{attrs:{id:"_17-版本特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_17-版本特点"}},[t._v("#")]),t._v(" 17 版本特点")]),t._v(" "),r("blockquote",[r("p",[t._v("在 V16 版本中，以 expirationTime 的大小来衡量优先级，expirationTime 越大，则优先级越高，\n但如果有一个高优先级异步 IO 任务（比如 Suspense，等待接口返回再执行后续操作）\n和低优先级的任务（比如 cpu 任务），那么按照目前的模型，高优先级任务会始终阻塞低优先级任务\n低优先级任务需要等待，直至高优先级 IO 任务执行完毕才会被执行，\n这样是不合理的，如何更好的处理高优先级和低优先级任务？")])]),t._v(" "),r("p",[t._v("使用 lanes 模型替代 expirationTime 模型")]),t._v(" "),r("ul",[r("li",[t._v("lanes 优先级管理: 解决了从前的每次只能执行一个任务，到现在可以同时执行多个任务的能力\n"),r("ul",[r("li",[t._v("lanes 指定一个连续的优先级区间，如果 update 的优先级在这个区间内，则将位于该区间内的任务生成对应的页面快照")]),t._v(" "),r("li",[t._v("lanes 使用 31 位的二进制，其中每个 bit 被称为一个 lane，代表优先级；")]),t._v(" "),r("li",[t._v("某几个 lane 组成的二进制数被称为一个 lanes，代表一批优先级，这样 react 可以分别给 IO 任务、低优先级的任务分配不同的 lane，最后可以并发执行这几种类型的优先级")])])])]),t._v(" "),r("blockquote",[r("p",[t._v("其本质是["),r("strong",[t._v("叠加算法")]),t._v("]，多个任务可以叠加表示，用 JS 来表示就是一个状态队列 "),r("code",[t._v("{ lanes: [1, 2, 3] }")]),t._v(",\n表示 fiber 有三个不同的优先级，他们应该被批处理")]),t._v(" "),r("p",[t._v('React 作者 acdlite 觉得操作状态队列不够方便，进而采用了一种"位运算代替状态队列"的方式：\n'),r("code",[t._v("{ lanes: 0b10010 }")]),t._v(", 新的 lane 算法中， lanes 是一个二进制数，比如 "),r("code",[t._v("10010")]),t._v(" 是由 "),r("code",[t._v("10000")]),t._v(" and "),r("code",[t._v("00010")]),t._v(" 两个任务叠加而成")])]),t._v(" "),r("p",[t._v("Fiber 及相关源码处理 详见文章："),r("a",{attrs:{href:"https://blog.ahulib.com/blog/Fiber%E8%AF%A6%E8%A7%A3",target:"_blank",rel:"noopener noreferrer"}},[t._v("Fiber详解"),r("OutboundLink")],1)]),t._v(" "),r("h3",{attrs:{id:"生命周期变更"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生命周期变更"}},[t._v("#")]),t._v(" 生命周期变更")]),t._v(" "),r("p",[r("img",{attrs:{src:a(370),alt:"React 16.4 以上生命周期"}})]),t._v(" "),r("h4",{attrs:{id:"挂载阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#挂载阶段"}},[t._v("#")]),t._v(" 挂载阶段")]),t._v(" "),r("ul",[r("li",[t._v("constructor")]),t._v(" "),r("li",[t._v("static getDerivedStateFromProps")]),t._v(" "),r("li",[t._v("render")]),t._v(" "),r("li",[t._v("componentDidMount")])]),t._v(" "),r("h4",{attrs:{id:"更新阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#更新阶段"}},[t._v("#")]),t._v(" 更新阶段")]),t._v(" "),r("ul",[r("li",[t._v("static getDerivedStateFromProps")]),t._v(" "),r("li",[t._v("shouldComponentUpdate")]),t._v(" "),r("li",[t._v("render")]),t._v(" "),r("li",[t._v("getSnapshotBeforeUpdate")]),t._v(" "),r("li",[t._v("componentDidUpdate")])]),t._v(" "),r("h4",{attrs:{id:"卸载阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#卸载阶段"}},[t._v("#")]),t._v(" 卸载阶段")]),t._v(" "),r("ul",[r("li",[t._v("componentWillUnmount")])]),t._v(" "),r("h4",{attrs:{id:"错误处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#错误处理"}},[t._v("#")]),t._v(" 错误处理")]),t._v(" "),r("ul",[r("li",[t._v("static getDerivedStateFromError")]),t._v(" "),r("li",[t._v("componentDidCatch")])]),t._v(" "),r("h3",{attrs:{id:"hook-是什么-常用的-api-最佳实践。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hook-是什么-常用的-api-最佳实践。"}},[t._v("#")]),t._v(" Hook 是什么？常用的 API，最佳实践。")]),t._v(" "),r("h3",{attrs:{id:"fiber-是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber-是什么"}},[t._v("#")]),t._v(" Fiber 是什么？")]),t._v(" "),r("h3",{attrs:{id:"一次渲染流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一次渲染流程"}},[t._v("#")]),t._v(" 一次渲染流程")]),t._v(" "),r("h3",{attrs:{id:"一次更新流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一次更新流程"}},[t._v("#")]),t._v(" 一次更新流程")]),t._v(" "),r("h2",{attrs:{id:"源码解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码解析"}},[t._v("#")]),t._v(" 源码解析")])])}),[],!1,null,null,null);e.default=_.exports}}]);